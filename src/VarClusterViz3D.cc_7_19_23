#include "VarClusterViz3D.hh"
#include "VarGaussianMixture.hh"

#include <TSystem.h>
#include <TGraph.h>
#include <TGraph2D.h>
#include <TF3.h>
#include <TColor.h>
#include <TROOT.h>
#include <TH2D.h>
#include <TMarker.h>
#include <TCanvas.h>
#include <TFile.h>
#include <TColor.h>
#include <TStyle.h>
#include <TAxis.h>
#include <TEllipse.h>
#include <string>

using std::string;


//check for 2D data
VarClusterViz3D::VarClusterViz3D(VarGaussianMixture* model, string fname){ 
	if(model->GetData().Dim() != 3){
		cout << "VarClusterViz3D Error: dimensionality of data is not 2. Dimensionality is " << model->GetData().Dim() << "." << endl;
		m_n = 0;
		return;
	}
	m_model = model;
	m_fname = fname;
	m_points = m_model->GetData();
	m_n = m_points.GetNPoints();
	m_k = m_model->GetNClusters(0.);
	m_post = m_model->GetPosterior();
	m_deltaT = 0.1;
	
	//normalize data
	m_shift = m_points.Center();
	//want to apply same transformation to points: (x - shift)/scale
	m_shift.Scale(-1);
	m_scale = m_points.Normalize();
	cout << "max - min (1/scale)" << endl;
	m_scale.Print();
	m_scale.Invert();

}

VarClusterViz3D::VarClusterViz3D(const VarClusterViz3D& viz){ 
	m_model = viz.m_model;
	if(m_model->GetData().Dim() != 3){
		cout << "VarClusterViz3D Error: dimensionality of data is not 2. Dimensionality is " << m_model->GetData().Dim() << "." << endl;
		m_n = 0;
		return;
	}
	m_fname = viz.m_fname;
	m_points = m_model->GetData();
	m_n = m_points.GetNPoints();
	m_k = m_model->GetNClusters(0.);
	m_post = m_model->GetPosterior();
	m_deltaT = 0.1;
	
	//normalize data
	m_shift = m_points.Center();
	//want to apply same transformation to points: (x - shift)/scale
	m_shift.Scale(-1);
	m_scale = m_points.Normalize();
	m_scale.Invert();
}

void VarClusterViz3D::AddPlot(double t, string plotName){
gErrorIgnoreLevel = kWarning;
	if(m_n == 0){
		return;
	}
	vector<Matrix> mus, covs;
	vector<double> pis;
	double pi_norm = 0;
	m_model->GetGausParameters(mus,covs);
	//normalize params

	m_model->GetMixingCoeffs(pis);
	vector<double> x, y;
	for(int i = 0; i < m_n; i++){
		//round time to nearest deltaT decimal place and plot if 0 < round(time) < t 
		if(std::ceil(m_points.at(i).Value(2) / m_deltaT) * m_deltaT > t) continue;
		//eta
		x.push_back(m_points.at(i).Value(0));
		//phi
		y.push_back(m_points.at(i).Value(1));
	}
	//if no points - empty plot
	if(x.size() == 0) return;

	for(int k = 0; k < m_k; k++){
	//	cout << "k: " << k << " pi: " << pis[k] << endl;
		pi_norm += pis[k];	
	}
	string cvName = "cv_"+plotName;
	TCanvas* cv = new TCanvas((cvName).c_str(),cvName.c_str());
	
	//get palette colors for circles
	SetPalette(m_k);
	auto cols = TColor::GetPalette();
	cv->Update();

	//sage green
	Int_t ci = TColor::GetFreeColorIndex();
	TColor* marker_color = new TColor(ci,0.61, 0.69, 0.53);  

	TGraph* gr_data = new TGraph((int)x.size(), &x[0], &y[0]);
	gr_data->SetTitle(("VarGMM EM Clustering "+plotName).c_str());
	gr_data->SetName(("VarGMM EM Clustering "+plotName).c_str());
	gr_data->SetMarkerStyle(24);
	gr_data->SetMarkerSize(0.95);
	gr_data->SetMarkerColorAlpha(ci,1);
	//can extend x/y axes so points aren't on border
	gr_data->GetXaxis()->SetTitle("eta-norm");
	gr_data->GetYaxis()->SetTitle("phi-norm");


/*
	TH1F* hist = gr_data->GetHistogram();
	//to turn off hist axes
	hist->GetXaxis()->SetLabelSize(0.);
	hist->GetXaxis()->SetTickLength(0.);
	hist->GetYaxis()->SetLabelSize(0.);
	hist->GetYaxis()->SetTickLength(0.);
	hist->SetFillStyle(4000);
*/
	//one pad
	TPad* graphPad = new TPad("graph pad", "graph pad",0.0,0.0,1.0,1.0);
	graphPad->Draw();

/*
	//another pad - draw on top
	TPad* circlePad = new TPad("circle pad", "circle pad",0.0,0.0,1.0,1.0);
	circlePad->SetFillStyle(4000);
	circlePad->SetFrameFillStyle(4000);
	circlePad->Draw();
*/
	//draw data	
	graphPad->cd();
	gr_data->Draw("ap");
	gr_data->GetYaxis()->SetRangeUser(-0.1,1.1);
	gr_data->GetXaxis()->SetLimits(-0.1,1.1);


//	circlePad->cd();
	//draw hist to place ellispes
//	hist->Draw("axis");
	int color_idx;
	//set coords for parameter circles
	double x0, y0, z0, c_x, c_y, r_x, r_y, deltaX, deltaY;
	double theta2, theta1, theta0, phi2, phi1, phi0, theta, phi;
	double ax_x, ax_y, ax_z;
	double r_a, r_b, r_c;
	vector<Matrix> eigenVecs;
	vector<double> eigenVals;
	double eigenx, eigeny, eigenz;
	//scale first
	Matrix mat_scale = Matrix(3, 3); //3D points
	Matrix mat_shift = Matrix(3, 1); //only for mean
	
	
	mat_scale.PointToScale(m_scale);
	mat_shift.PointToShift(m_shift);
	for(int k = 0; k < m_k; k++){
		//if mean mixing coefficient value is indistinguishable from zero, don't draw
		if(pis[k]/pi_norm < 0.01)
			continue; 

		//do same normalization transformation on parameters
		//then shift -> mu'' = mu' - shift = scale*mu - shift
		//shift mus[k]
		mus[k].add(mat_shift);
		//scale mus[k] => mu' = scale*mu
		mus[k].mult(mat_scale,mus[k]);
		x0 = mus[k].at(0,0);
		y0 = mus[k].at(1,0);
		z0 = mus[k].at(2,0);

		cout << "k: " << k << " original cov:" << endl;
		covs[k].Print();

		//scale covs
		//Matrix cov_inv;
		//cov_inv.invert(covs[k]);
		//cout << "inverse cov" << endl;
		//cov_inv.Print();

		//cov_inv.mult(mat_scale,cov_inv);
		//cov_inv.mult(cov_inv,mat_scale);

		//cout << "scaled inverse cov" << endl;
		//cov_inv.Print();
		
		covs[k].mult(mat_scale,covs[k]);
		covs[k].mult(covs[k],mat_scale);
		cout << "k: " << k << " scaled cov:" << endl;
		covs[k].Print();
		covs[k].eigenCalc(eigenVals, eigenVecs);
/*
		//eigenvalues are sorted on output, not associated with any particular dim
		eigenVals[0] = 1.44;
		eigenVals[1] = 3.45;
		eigenVals[2] = 2.02;
	
		eigenVecs[0].SetEntry(-0.460021,0,0);
		eigenVecs[0].SetEntry(-0.241295,1,0);
		eigenVecs[0].SetEntry(-0.854493,2,0);

		eigenVecs[1].SetEntry(-0.641846,0,0);
		eigenVecs[1].SetEntry(0.755344,1,0);
		eigenVecs[1].SetEntry(0.132244,2,0);
		
		eigenVecs[2].SetEntry(-0.613526,0,0);
		eigenVecs[2].SetEntry(-0.609288,1,0);
		eigenVecs[2].SetEntry(0.502348,2,0);

		vector<vector<double>> u, v;
		int npts_u, npts_v;
		npts_u = 3;
		npts_v = 3;
		Matrix points1, points2;
		points1 = Matrix(3,npts_u*npts_v);
		points2 = Matrix(3,npts_u*npts_v);
		for(int i = 0; i < npts_u; i++){
			u.push_back({});
			for(int j = 0; j < npts_u; j++){
			u[i].push_back((i/(double(npts_u)-1))*2*acos(-1));
			cout << "i: " << i << " j: " << j << " u[i]: " << u[i][j] << endl;
			}
		}
		for(int i = 0; i < npts_v; i++){
			v.push_back({});
			for(int j = 0; j < npts_v; j++){
			v[i].push_back((j/(double(npts_v)-1))*acos(-1));
			}
		}
		Matrix x1, y1, z1;
		x1 = Matrix(npts_u, npts_v);
		y1 = Matrix(npts_u, npts_v);
		z1 = Matrix(npts_u, npts_v);
		for(int i = 0; i < npts_u; i++){
			for(int j = 0; j < npts_v; j++){
			x1.SetEntry(eigenVals[0]*cos(u[i][j])*sin(v[i][j]),i,j);	
			y1.SetEntry(eigenVals[1]*sin(u[i][j])*sin(v[i][j]),i,j);	
			z1.SetEntry(eigenVals[2]*cos(v[i][j]),i,j);
			}
		}
		//flatten
		vector<double> x_vec, y_vec, z_vec;
		for(int i = 0; i < npts_u; i++){
			for(int j = 0; j < npts_v; j++){
				x_vec.push_back(x1.at(i,j));
				y_vec.push_back(y1.at(i,j));
				z_vec.push_back(z1.at(i,j));
			}
		}
		for(int i = 0; i < npts_u*npts_v; i++){
			points1.SetEntry(x_vec[i],0,i);
			points1.SetEntry(y_vec[i],1,i);
			points1.SetEntry(z_vec[i],2,i);
		}

cout << "points" << endl;
points1.Print();

		Matrix T = Matrix(3,3);
		for(int i = 0; i < 3; i++){
			for(int j = 0; j < 3; j++){
				T.SetEntry(eigenVecs[i].at(j,0),i,j);
			}
		}	
cout << "eigenmatrix" << endl;
		Matrix T_T = Matrix(3,3);
		T_T.transpose(T);
		T_T.Print();

		points2.mult(T_T,points1);
		points2.Print();
		vector<double> x2, y2, z2;
		for(int i = 0; i < npts_u*npts_v; i++){
			x2.push_back(points2.at(0,i));
			y2.push_back(points2.at(1,i));
			z2.push_back(points2.at(2,i));
		}


		TGraph* circle = new TGraph(npts_u*npts_v, &x_vec[0], &y_vec[0]);
		circle->SetLineColor(kRed);
		circle->Draw();


		r_a = sqrt(eigenVals[0]);
		r_b = sqrt(eigenVals[1]);
		r_c = sqrt(eigenVals[2]);

		//phi is angle in x-y plane: phi = arctan(y/x)
		//take direction of largest eigenvalue (principle axis) - always last one
		ax_x = eigenVecs[2].at(0,0);
		ax_y = eigenVecs[2].at(1,0);
		ax_z = eigenVecs[2].at(2,0);
		phi2 = atan2(ax_y, ax_x);
		//theta is angle from z-axis: theta = arccos(z/r), r = sqrt(x^2 + y^2 + z^2)
		theta2 = acos(ax_z/sqrt(ax_x*ax_x + ax_y*ax_y + ax_z*ax_z));
		phi = phi2;
		theta = theta2;

		ax_x = eigenVecs[1].at(0,0);
		ax_y = eigenVecs[1].at(1,0);
		ax_z = eigenVecs[1].at(2,0);

		theta1 = acos(ax_z/sqrt(ax_x*ax_x + ax_y*ax_y + ax_z*ax_z));
		phi1 = atan2(ax_y, ax_x);
		ax_x = eigenVecs[0].at(0,0);
		ax_y = eigenVecs[0].at(1,0);
		ax_z = eigenVecs[0].at(2,0);

		theta0 = acos(ax_z/sqrt(ax_x*ax_x + ax_y*ax_y + ax_z*ax_z));
		phi0 = atan2(ax_y, ax_x);

		//calculate center shifts in x-y plane (based on angle from z-axis theta)
		deltaX = cos(phi2)*sin(theta2);
		deltaY = sin(phi2)*sin(theta2);
	
if(k == 1) cout << "deltaX2: " << deltaX << " deltaY2: " << deltaY << endl;
		deltaX = cos(phi1)*sin(theta1);
		deltaY = sin(phi1)*sin(theta1);
	
if(k == 1) cout << "deltaX1: " << deltaX << " deltaY1: " << deltaY << endl;
		deltaX = cos(phi0)*sin(theta0);
		deltaY = sin(phi0)*sin(theta0);
	
if(k == 1) cout << "deltaX0: " << deltaX << " deltaY0: " << deltaY << endl;
*/
		//project onto x-y plane
		//r_x = r_c*sqrt(1 - ((t - z0)*(t - z0))/(r_c*r_c) );
		//r_y = r_b*sqrt(1 - ((t - z0)*(t - z0))/(r_c*r_c) );

		/*
		//3D x^2 coeff
		double a_3d = 0.25;//covs[k].at(0,0);
		//3D y^2 coeff
		double b_3d = 0.9;//covs[k].at(1,1);
		//3D z^2 coeff
		double c_3d = 0.01;//covs[k].at(2,2);
		//3D xy coeff
		double d_3d = 0.;//covs[k].at(0,1);
		//3D xz coeff
		double e_3d = 0.;//covs[k].at(0,2);
		//3D yz coeff
		double f_3d = 0.;//covs[k].at(1,2);
		//with z = t in 3D eqn -> 2D eqn
		//a scaled = a/(1 - c*t^2) for delta = z;
		//2D x^2 coeff
		double a_z = a/(1 - c*(t - z0)*(t - z0));
		//2D xy coeff
		double b_z = d/(1 - c*(t - z0)*(t - z0)); 
		//2D y^2 coeff
		double c_z = b/(1 - c*(t - z0)*(t - z0));
		r_x = sqrt(a_z);
		r_y = sqrt(c_z);		
		//theta = 0.5*arccot((a_z - c_z)/b_z)) if b_z != 0
		double arg;
		if(b_z != 0){
			arg = (a_z - c_z)/b_z;
			if(a_z > c_z){
				theta = acos(-1)/2. + 0.5*acos(arg)/asin(arg);
			}
			else theta = 0.5*acos(arg)/asin(arg);
		}
		else{
			if(a_z > c_z){
				theta = acos(-1)/2.;
			}
			else theta = 0;
		}	
		double a = a_3d;
		double b = 2*d_3d;
		double c = b_3d;
		double d = 2*e_3d*(t - z0);
		double e = 2*f_3d*(t - z0);
		double f = c_3d*(t - z0)*(t - z0) - 1;
		double a = a_3d;
		double b = 2*d_3d;
		double c = b_3d;
		double d = -2*a_3d*x0 - 2*d_3d*x0 + 2*e_3d*(t - z0);
		double e = -2*b_3d*y0 - 2*d_3d*y0 + 2*f_3d*(t - z0);
		double f = a_3d*x0*x0 + b_3d*y0*y0 + c_3d*(t - z0)*(t - z0) + 2*d_3d*x0*y0 - 2*e_3d*(t - z0)*x0 - 2*f_3d*(t - z0)*y0;

	cout << "a: " << a << " b: " << b << " c: " << c << " d: " << d << " e: " << e << " f: " << f << endl;
		double det = (a*c - 0.25*b*b)*f + 0.25*b*e*d - 0.25*c*d*d - 0.25*a*e*e;
		if(c*det < 0) cout << "real" << endl;
		else if(c*det > 0) cout << "imaginary" << endl;
		else cout << "point" << endl;

		double sqrt_sqrt_arg = (a - c)*(a - c) + b*b;
		double sqrt_arg = a*e*e + c*d*d - b*d*e + (b*b - 4*a*c)*f;
		cout << "sqrt_sqrt_arg: " << sqrt_sqrt_arg << " sqrt_arg: " << sqrt_arg << " denom: " << (b*b - 4*a*c) << endl;
		r_x = (-sqrt(2*sqrt_arg*((a + c) + sqrt(sqrt_sqrt_arg))) )/(b*b - 4*a*c);	
		r_y = (-sqrt(2*sqrt_arg*((a + c) - sqrt(sqrt_sqrt_arg))) )/(b*b - 4*a*c);	

		if(b != 0){
			theta = 1./atan( (c - a - sqrt(sqrt_sqrt_arg))/b );
		}
		else{
			if(a > c)
				theta = acos(-1)/2.;
			else
				theta = 0;
		}	

	
		c_x = x0;// + deltaX;
		c_y = y0;// + deltaY;
		*/

	//ellipse plotted is based off of ellipsoid principal axis - x+y axes correspond to x+y components of principal axis (approximation of true 1 sigma ellipsoid, which has x+y components from other axes) 

//cout << "dims" << endl;
//dims.Print();
cout << "k: " << k <<  " t: " << t << " c_x: " << c_x << " c_y: " << c_y << " r_x: " << r_x << " r_y: " << r_y << endl;
cout << "x0: " << x0 << " y0: " << y0 << " z0: " << z0 << " pi: " << pis[k] << endl;	
//cout << "a_z: " << a_z << " b_z: " << b_z << " c_z: " << c_z << endl;
//cout << "r_a: " << r_a << " r_b: " << r_b << " r_c: " << r_c << endl;
//cout << "deltaX: " << deltaX << " deltaY: " << deltaY << endl;
//cout << "tan(theta)*sin(phi): " << tan(theta)*sin(phi) << " tan(theta)*cos(phi): " << tan(theta)*cos(phi) << endl;
cout << "scale x: " << m_scale.at(0) << " scale y: " << m_scale.at(1) << " scale z: " << m_scale.at(2) << endl;
cout << "t-z0: " << (t - z0) << endl;
cout << "(t-z0)^2: " << (t - z0)*(t - z0) << endl;
cout << "1 - (t-z0)^2: " << 1 - (t - z0)*(t - z0) << endl;
cout << "theta: " << theta << endl;
//cout << "eigen vec 0: " << eigenVals[0] << endl;
//eigenVecs[0].Print();
//cout << "eigen vec 1: " << eigenVals[1] << endl;
//eigenVecs[1].Print();
//cout << "eigen vec 2: " << eigenVals[2] << endl;
//eigenVecs[2].Print();
cout << "\n" << endl;
		//if rx or ry is nan -> ellipse doesn't exist at this value of t
		if(isnan(r_x) || isnan(r_y)){ 
			continue;
		}
	
		continue;
/*
		//convert to degrees for plotting
		theta = 180*theta/acos(-1);	
		//if(theta < 0) theta = -(90+theta);
		//else theta += 90;
		//else phi += 90; //get in ROOT's weird angle definition
		TEllipse* circle = new TEllipse(c_x, c_y, r_x, r_y,0,360, phi);
		TEllipse* circle_bkg = new TEllipse(c_x, c_y, r_x, r_y,0,360, phi);
		auto col = cols[int(double(k) / double(m_k - 1)*(cols.GetSize() - 1))];
		circle->SetFillColorAlpha(col,pis[k]/pi_norm);
		circle->SetLineColor(col);
		circle->SetLineWidth(5);
		//sets transparency normalized to sum
	//	cout << "k: " << k << " transparency: " << pis[k]/pi_norm << endl;
	   	circle->SetFillStyle(1001);

	///cout << "\n" << endl;

		circle_bkg->SetLineColor(0); 
		circle_bkg->SetLineWidth(8);
	   	circle_bkg->SetFillStyle(0);
		//circle_bkg->Draw();
		circle->Draw("f");
*/


	}
	m_cvs.push_back(cv);

}




void VarClusterViz3D::SeeData(){
	vector<double> x, y, z;
	for(int i = 0; i < m_n; i++){
		//eta
		x.push_back(m_points.at(i).Value(0));
		//phi
		y.push_back(m_points.at(i).Value(1));
		//time
		z.push_back(m_points.at(i).Value(2));
	}
	
if(m_n == 0 || x.size() == 0){
	cout << "Error: no data to plot." << endl;
	return;
}
	string cvName = "cv_data";//+plotName+"_tEq"+std::to_string(t).substr(0,3);
	cout << "cvName: " << cvName << endl;
	TCanvas* cv = new TCanvas((cvName).c_str(),cvName.c_str());
	
	//sage green
	Int_t ci = TColor::GetFreeColorIndex();
	TColor* marker_color = new TColor(ci,0.61, 0.69, 0.53);  

	
//cout << "n pts: " << x.size() << endl;
	TGraph2D* gr_data = new TGraph2D((int)x.size(), &x[0], &y[0], &z[0]);
	gr_data->SetTitle("VarGMM EM Clustering - data only");
	gr_data->SetName("VarGMM EM Clustering - data only");
	gr_data->SetMarkerStyle(24);
	gr_data->SetMarkerSize(0.95);
	gr_data->SetMarkerColorAlpha(ci,1);
	//can extend x/y axes so points aren't on border
	gr_data->GetXaxis()->SetTitle("X");
	gr_data->GetYaxis()->SetTitle("Y");
	gr_data->GetZaxis()->SetTitle("Z");
	
	gr_data->Draw("p");

	m_cvs.push_back(cv);

}

void VarClusterViz3D::AddAnimation(string dirname){
	//out folder does not exist
	//ie) dirname = it_0
	if(gSystem->AccessPathName((m_fname+"/"+dirname).c_str())){
		gSystem->Exec(("mkdir -p "+m_fname+"/"+dirname).c_str());
	}

	//get max + min time
	double tMax = m_points.max(2);
	double tMin = m_points.min(2);
	//nsteps = m_deltaT*(tMax - tMin)
	//loop through iterations of time
	int idx = std::to_string(m_deltaT).find("1")+1;
	double t = tMin;
	
	vector<string> tlabels;
	string label;
	while(t < tMax){
		string t_str = std::to_string(t);
		std::size_t idx1 = t_str.find(".");
		t_str.replace(idx1,1,"p");
		t_str = t_str.substr(0,idx1+3);
	//	if(std::to_string(t).find("-") != string::npos)
	//		t_str = "m"+t_str;
	//	else
	//		t_str = "p"+t_str;
		AddPlot(t, dirname+"_"+t_str);
		tlabels.push_back(t_str);
		t += m_deltaT;
	}


	//write series of plots in time
	cout << "Writing plots and gif to: ./" << m_fname << "/" << dirname << endl;
	for(int i = 0; i < m_cvs.size(); i++){
		m_cvs[i]->SaveAs((m_fname+"/"+dirname+"/cv_tEq"+tlabels[i]+".gif").c_str());
	}
	
	gSystem->cd((m_fname+"/"+dirname).c_str());
	gSystem->Exec(("rm "+dirname+".gif").c_str());
	gSystem->Exec(("convert -delay 50 -loop 1 *.gif "+dirname+".gif").c_str());
	gSystem->cd("../../../");
	m_cvs.clear();
	

	



}


void VarClusterViz3D::Write(){
	if(m_n == 0){
		return;
	}
	cout << "Writing plot(s) to: ./" << m_fname << ".root" << endl;
	TFile* f = TFile::Open((m_fname+".root").c_str(),"RECREATE");	
	f->cd();
	SetPalette(m_k);
	//write to root file
	for(int i = 0; i < m_cvs.size(); i++){
		m_cvs[i]->Write();
	}
	f->Close();


}




void VarClusterViz3D::SetPalette(int k){
	gStyle->cd();

	//create color palette - max number of clusters = 10
	//additional ones need to be added by hand here

	//number of gradients in the palette
	int nColors = 100;
	//set color palette
	vector<double> stops, red, green, blue;
	//number of end point colors
	int nMainColors = k;

	if(k < 2){
		cout << "Error: please give at least 2 clusters for palette creation." << endl;
		return;
	}

	//[0,1] values are R, G or B/255.
	//first color = light blue
	red.push_back(0.52);
	green.push_back(0.79);
	blue.push_back(0.96);
	//second color = light pink
	red.push_back(0.89);
	green.push_back(0.52);
	blue.push_back(0.96);

	//third color = light green
	red.push_back(0.52);
	green.push_back(0.95);
	blue.push_back(0.79);

	//fourth color = light purple
	red.push_back(0.67);
	green.push_back(0.52);
	blue.push_back(0.95);

	//fifth color = light orange
	red.push_back(0.95);
	green.push_back(0.796);
	blue.push_back(0.52);

	//sixth color = light yellow
	red.push_back(0.95);
	green.push_back(0.89);
	blue.push_back(0.52);

	
	//where to switch colors
	stops.push_back(0.0);
	stops.push_back(0.16666);
	stops.push_back(0.33333);
	stops.push_back(0.5);
	stops.push_back(0.66666);
	stops.push_back(0.83333);
	stops.push_back(1.0);

	Int_t fi = TColor::CreateGradientColorTable(nMainColors,&stops[0],&red[0],&green[0],&blue[0],nColors);
	for (int i=0;i<nColors;i++) m_palette[i] = fi+i;
	//cout << "pal - first color: " << m_palette[0] << " last color: " << m_palette[99] << endl;
}

